// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: credential.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const addCredential = `-- name: AddCredential :one
SELECT add_credential_with_access($1::JSONB)
`

func (q *Queries) AddCredential(ctx context.Context, dollar_1 json.RawMessage) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, addCredential, dollar_1)
	var add_credential_with_access uuid.UUID
	err := row.Scan(&add_credential_with_access)
	return add_credential_with_access, err
}

const createCredential = `-- name: CreateCredential :one
INSERT INTO credentials (name, description, folder_id, created_by)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateCredentialParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	FolderID    uuid.NullUUID  `json:"folder_id"`
	CreatedBy   uuid.NullUUID  `json:"created_by"`
}

// sql/create_credential.sql
func (q *Queries) CreateCredential(ctx context.Context, arg CreateCredentialParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createCredential,
		arg.Name,
		arg.Description,
		arg.FolderID,
		arg.CreatedBy,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createEncryptedData = `-- name: CreateEncryptedData :one
INSERT INTO encrypted_data (field_name, credential_id, field_value, user_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateEncryptedDataParams struct {
	FieldName    string        `json:"field_name"`
	CredentialID uuid.NullUUID `json:"credential_id"`
	FieldValue   string        `json:"field_value"`
	UserID       uuid.NullUUID `json:"user_id"`
}

func (q *Queries) CreateEncryptedData(ctx context.Context, arg CreateEncryptedDataParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createEncryptedData,
		arg.FieldName,
		arg.CredentialID,
		arg.FieldValue,
		arg.UserID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUnencryptedData = `-- name: CreateUnencryptedData :one
INSERT INTO unencrypted_data (field_name, credential_id, field_value)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateUnencryptedDataParams struct {
	FieldName    string        `json:"field_name"`
	CredentialID uuid.NullUUID `json:"credential_id"`
	FieldValue   string        `json:"field_value"`
}

func (q *Queries) CreateUnencryptedData(ctx context.Context, arg CreateUnencryptedDataParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUnencryptedData, arg.FieldName, arg.CredentialID, arg.FieldValue)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const fetchCredentialsByUserAndFolder = `-- name: FetchCredentialsByUserAndFolder :many
SELECT c.id AS credential_id, 
       c.name AS credential_name, 
       c.description AS credential_description, 
       json_agg(json_build_object('field_name', u.field_name, 'field_value', u.field_value)) AS unencrypted_data
FROM credentials c
JOIN access_list a ON c.id = a.credential_id
LEFT JOIN unencrypted_data u ON c.id = u.credential_id
WHERE a.user_id = $1 AND c.folder_id = $2
GROUP BY c.id, c.name, c.description
`

type FetchCredentialsByUserAndFolderParams struct {
	UserID   uuid.NullUUID `json:"user_id"`
	FolderID uuid.NullUUID `json:"folder_id"`
}

type FetchCredentialsByUserAndFolderRow struct {
	CredentialID          uuid.UUID       `json:"credential_id"`
	CredentialName        string          `json:"credential_name"`
	CredentialDescription sql.NullString  `json:"credential_description"`
	UnencryptedData       json.RawMessage `json:"unencrypted_data"`
}

func (q *Queries) FetchCredentialsByUserAndFolder(ctx context.Context, arg FetchCredentialsByUserAndFolderParams) ([]FetchCredentialsByUserAndFolderRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchCredentialsByUserAndFolder, arg.UserID, arg.FolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchCredentialsByUserAndFolderRow{}
	for rows.Next() {
		var i FetchCredentialsByUserAndFolderRow
		if err := rows.Scan(
			&i.CredentialID,
			&i.CredentialName,
			&i.CredentialDescription,
			&i.UnencryptedData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCredentialDetails = `-- name: GetCredentialDetails :one
SELECT id, name, description
FROM credentials
WHERE id = $1
`

type GetCredentialDetailsRow struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) GetCredentialDetails(ctx context.Context, id uuid.UUID) (GetCredentialDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getCredentialDetails, id)
	var i GetCredentialDetailsRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getCredentialUnencryptedData = `-- name: GetCredentialUnencryptedData :many
SELECT field_name, field_value
FROM unencrypted_data
WHERE credential_id = $1
`

type GetCredentialUnencryptedDataRow struct {
	FieldName  string `json:"field_name"`
	FieldValue string `json:"field_value"`
}

func (q *Queries) GetCredentialUnencryptedData(ctx context.Context, credentialID uuid.NullUUID) ([]GetCredentialUnencryptedDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getCredentialUnencryptedData, credentialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCredentialUnencryptedDataRow{}
	for rows.Next() {
		var i GetCredentialUnencryptedDataRow
		if err := rows.Scan(&i.FieldName, &i.FieldValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEncryptedData = `-- name: GetUserEncryptedData :many
SELECT field_name, field_value
FROM encrypted_data
WHERE user_id = $1 AND credential_id = $2
`

type GetUserEncryptedDataParams struct {
	UserID       uuid.NullUUID `json:"user_id"`
	CredentialID uuid.NullUUID `json:"credential_id"`
}

type GetUserEncryptedDataRow struct {
	FieldName  string `json:"field_name"`
	FieldValue string `json:"field_value"`
}

func (q *Queries) GetUserEncryptedData(ctx context.Context, arg GetUserEncryptedDataParams) ([]GetUserEncryptedDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserEncryptedData, arg.UserID, arg.CredentialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserEncryptedDataRow{}
	for rows.Next() {
		var i GetUserEncryptedDataRow
		if err := rows.Scan(&i.FieldName, &i.FieldValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const shareSecret = `-- name: ShareSecret :exec
SELECT share_secret($1, $2, $3, $4, $5)
`

type ShareSecretParams struct {
	PUserID       uuid.UUID `json:"p_user_id"`
	PCredentialID uuid.UUID `json:"p_credential_id"`
	PFieldNames   string    `json:"p_field_names"`
	PFieldValues  string    `json:"p_field_values"`
	PAccessType   string    `json:"p_access_type"`
}

func (q *Queries) ShareSecret(ctx context.Context, arg ShareSecretParams) error {
	_, err := q.db.ExecContext(ctx, shareSecret,
		arg.PUserID,
		arg.PCredentialID,
		arg.PFieldNames,
		arg.PFieldValues,
		arg.PAccessType,
	)
	return err
}
